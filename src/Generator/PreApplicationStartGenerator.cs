// MIT License.

using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;

namespace Compiler.Generator;

[Generator]
public class PreApplicationStartGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor InvalidPreApplicationStartMethod = new DiagnosticDescriptor(
        id: "WEBFORMS1000",
        title: "Invalid PreApplicationStartMethod",
        messageFormat: "Invalid PreApplicationStartMethod in {0} for {1}.{2}",
        category: "WebForms",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    private sealed record PreApplicationStartMethod(string Assembly, string TypeName, string MethodName, bool IsStatic, bool IsValid);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var invocation = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node.TryGetMapMethodName(out var method) && method == "AddPreApplicationStartMethod",
            transform: static (context, token) =>
            {
                var operation = context.SemanticModel.GetOperation(context.Node, token);
                if (operation is IInvocationOperation invocation)
                {
                    return invocation.GetLocation();
                }
                return default;
            })
            .Where(static invocation => invocation is { });

        var startMethods = context.CompilationProvider.Select((compilation, token) =>
        {
            var startMethods = ImmutableArray.CreateBuilder<PreApplicationStartMethod>();

            foreach (var (type, name) in compilation.FindPreApplicationStartAttributes())
            {
                if (IsValidMethod(type, name) is { } member)
                {
                    startMethods.Add(new(type.ContainingAssembly.Name, type.ToString(), name, member.IsStatic, IsValid: true));
                }
                else
                {
                    startMethods.Add(new(type.ContainingAssembly.Name, type.ToString(), name, false, IsValid: false));
                }

                static IMethodSymbol? IsValidMethod(INamedTypeSymbol type, string name)
                {
                    if (!type.TypeParameters.IsDefaultOrEmpty)
                    {
                        return null;
                    }

                    if (type.GetMembers(name) is not [IMethodSymbol method])
                    {
                        return null;
                    }

                    if (method is { IsStatic: false } && !type.Constructors.Any(c => c.Parameters.IsDefaultOrEmpty))
                    {
                        return null;
                    }

                    if (method is { TypeArguments.IsDefaultOrEmpty: true, Parameters.IsDefaultOrEmpty: true, ReturnsVoid: true } member)
                    {
                        return method;
                    }

                    return null;
                }
            }

            return startMethods.ToImmutable();
        });

        context.RegisterSourceOutput(invocation.Combine(startMethods), (context, source) =>
        {
            if (source.Left is not { } location)
            {
                return;
            }

            var startups = source.Right;

            using var str = new StringWriter();
            using var indented = new IndentedTextWriter(str);

            indented.WriteLine("ï»¿// <auto-generated />");
            indented.WriteLine();
            indented.WriteLine("using Microsoft.AspNetCore.Builder;");
            indented.WriteLine("using Microsoft.AspNetCore.Hosting;");
            indented.WriteLine("using Microsoft.AspNetCore.SystemWebAdapters;");
            indented.WriteLine("using Microsoft.AspNetCore.SystemWebAdapters.HttpHandlers;");
            indented.WriteLine("using Microsoft.Extensions.FileProviders;");
            indented.WriteLine("using Microsoft.Extensions.Primitives;");
            indented.WriteLine("using Microsoft.Extensions.DependencyInjection;");
            indented.WriteLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            indented.WriteLine("using Microsoft.Extensions.Options;");
            indented.WriteLine("using Microsoft.Extensions.Logging;");
            indented.WriteLine("using System;");
            indented.WriteLine();
            indented.WriteLine("#pragma warning disable");
            indented.WriteLine();
            indented.WriteLine("namespace WebForms.Generated");
            indented.WriteLine("{");
            indented.Indent++;
            indented.WriteLine("internal static class InterceptedPreApplicationStartMethods");
            indented.WriteLine("{");
            indented.Indent++;
            indented.Write("[System.Runtime.CompilerServices.InterceptsLocation(\"");
            indented.Write(location.FilePath.Replace("\\", "\\\\"));
            indented.Write("\", ");
            indented.Write(location.Line);
            indented.Write(", ");
            indented.Write(location.Character);
            indented.WriteLine(")]");
            indented.WriteLine("internal static ISystemWebAdapterBuilder AddPreApplicationStartMethod(this ISystemWebAdapterBuilder builder, bool failOnError = true)");
            indented.WriteLine("{");
            indented.Indent++;

            if (!startups.IsDefaultOrEmpty)
            {
                indented.WriteLine("builder.Services.AddOptions<PreApplicationOptions>()");
                indented.Indent++;
                indented.WriteLine(".Configure(options => options.FailOnError = failOnError);");
                indented.Indent--;
                indented.WriteLine();
                indented.WriteLine("builder.Services.AddHostedService<PreApplicationStartMethodBackgroundService>();");
            }

            indented.WriteLine("return builder;");
            indented.Indent--;
            indented.WriteLine("}");

            if (!startups.IsDefaultOrEmpty)
            {
                indented.WriteLine();
                indented.WriteLine("private sealed class PreApplicationOptions");
                indented.WriteLine("{");
                indented.Indent++;
                indented.WriteLine("public bool FailOnError { get; set; }");
                indented.Indent--;
                indented.WriteLine("}");
                indented.WriteLine();

                indented.WriteLine("private sealed class PreApplicationStartMethodBackgroundService(IOptions<PreApplicationOptions> options, ILogger<PreApplicationStartMethodBackgroundService> logger) : BackgroundService");
                indented.WriteLine("{");
                indented.Indent++;
                indented.WriteLine("protected override Task ExecuteAsync(CancellationToken stoppingToken)");
                indented.WriteLine("{");
                indented.Indent++;
                indented.WriteLine("RunStartupMethods(options.Value.FailOnError);");
                indented.WriteLine("return Task.CompletedTask;");
                indented.Indent--;
                indented.WriteLine("}");
                indented.WriteLine();
                indented.WriteLine("private void RunStartupMethods(bool failOnError)");
                indented.WriteLine("{");

                indented.Indent++;


                foreach (var (assembly, typeName, methodName, isStatic, isValid) in startups)
                {
                    indented.WriteLine("{");
                    indented.Indent++;

                    if (isValid)
                    {
                        indented.WriteLine("try");
                        indented.WriteLine("{");
                        indented.Indent++;
                        indented.WriteLine($"logger.LogInformation(\"Invoking PreApplicationStartMethod: {{TypeName}}.{{MethodName}}\", \"{typeName}\", \"{methodName}\");");
                    }

                    if (!isValid)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(InvalidPreApplicationStartMethod, location: null, assembly, typeName, methodName));
                        indented.Write("// Invalid pre application start method: ");
                    }

                    if (isStatic)
                    {
                        indented.WriteLine($"{typeName}.{methodName}();");
                    }
                    else
                    {
                        indented.WriteLine($"new {typeName}().{methodName}();");
                    }

                    if (isValid)
                    {
                        indented.Indent--;
                        indented.WriteLine("}");
                        indented.WriteLine("catch (Exception e) when (!failOnError)");
                        indented.WriteLine("{");
                        indented.Indent++;
                        indented.WriteLine($"logger.LogError(e, \"Unexpected error invoking PreApplicationStartMethod: {{TypeName}}.{{MethodName}}\", \"{typeName}\", \"{methodName}\");");
                        indented.Indent--;
                        indented.WriteLine("}");
                    }

                    indented.Indent--;
                    indented.WriteLine("}");
                }

                indented.Indent--;
                indented.WriteLine("}");
                indented.Indent--;
                indented.WriteLine("}");
            }

            indented.Indent--;
            indented.WriteLine("}");
            indented.Indent--;
            indented.WriteLine("}");
            indented.Indent--;
            indented.WriteLine();

            indented.Write("""
                    namespace System.Runtime.CompilerServices
                    {
                        [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                        file sealed class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute
                        {
                        }
                    }
                    """);

            var result = str.ToString();
            context.AddSource("PreApplicationStartMethod", result);
        });
    }
}
